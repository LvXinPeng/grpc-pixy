// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kafkapixy.proto

package com.csvw.lib;

/**
 * Protobuf service {@code KafkaPixyService}
 */
public  abstract class KafkaPixyService
    implements com.google.protobuf.Service {
  protected KafkaPixyService() {}

  public interface Interface {
    /**
     * <pre>
     * Produce writes a message to a Kafka topic.
     * If ProdReq.async_mode is false (default value) then the request will
     * block until the message is written to all ISR. In this case the respose
     * will contain the partition and offset of the message. This has to be
     * used to achive at-least-once deliverability guarantee.
     * If ProdReq.async_mode is true, then Kafka-Pixy returns immediately after
     * it gets the request and performs write on the backgroud. This mode
     * ensures highest throughput but messages can be lost, e.g. if the host
     * crashes before Kafka-Pixy has a chance to complete write.
     * Hash of ProdReq.key_value is used to determine a partition that the
     * message should be written to. If you want a message to go to an random
     * partition then set ProdReq.key_undefined to true. Note that if both
     * ProdReq.key_undefined and ProdReq.key_value are left default, which is
     * empty string and false respectively, then messages will be consitently
     * written to a partiticular partition selected by the hash of an empty
     * string.
     * gRPC error codes:
     *  * Invalid Argument (3): see the status description for details;
     *  * Internal (13): see the status description and logs for details;
     *  * Unavailable (14): the service is shutting down.
     * </pre>
     *
     * <code>rpc Produce(.ProdRq) returns (.ProdRs);</code>
     */
    public abstract void produce(
            com.google.protobuf.RpcController controller,
            ProdRq request,
            com.google.protobuf.RpcCallback<ProdRs> done);

    /**
     * <pre>
     * Consume reads a message from a topic and optionally acknowledges a
     * message previously consumed from the same topic.
     * Requests are performed in long polling fation, that is if all available
     * messages have been consumed then the request will block for
     * config.yaml:proxies.&lt;cluster&gt;.consumer.long_polling_timeout waiting for
     * new messages. If no new messages is produced while waiting the request
     * will return gRPC error with 408 status code.
     * To consume the first message set ConsNAckReq.no_ack to true, since there
     * is no message to acknowledge at this point. In the second and all
     * subsequent calls of the method set ConsNAckReq.ack_partition and
     * ConsNAckReq.ack_offset to the respective values of ConsRes returned by
     * the previous method call. To acknowledge the last consumed message before
     * teminating the application call Ack method.
     * If a message is not acknowledged within
     * config.yaml:proxies.&lt;cluster&gt;.consumer.ack_timeout the it will be returned
     * by Kafka-Pixy in ConsRes again possibly to another application.
     * If at-least-once delivery guarantee and retries are not desirable, then
     * you can set ConsNAckReq.auto_ack to true and Kafka-Pixy will acknowledge
     * messages automatically before returning them in ConsRes.
     * gRPC error codes:
     *  * Not Found (5): It just means that all message has been consumed and
     *    the long polling timeout has elaspsed. Just keep calling this method
     *    in a loop;
     *  * Resource Exhausted (8): too many consume requests. Either reduce the
     *    number of consuming threads or increase
     *    config.yaml:proxies.&lt;cluster&gt;.consumer.channel_buffer_size;
     *  * Invalid Argument (3): see the status description for details;
     *  * Internal (13): see the status description and logs for details;
     *  * Unavailable (14): the service is shutting down.
     * </pre>
     *
     * <code>rpc ConsumeNAck(.ConsNAckRq) returns (.ConsRs);</code>
     */
    public abstract void consumeNAck(
            com.google.protobuf.RpcController controller,
            ConsNAckRq request,
            com.google.protobuf.RpcCallback<ConsRs> done);

    /**
     * <pre>
     * Ack acknowledges a message earlier consumed from a topic.
     * This method is provided solely to acknowledge the last consumed message
     * before the application terminates. In all other cases ConsumeNAck should
     * be used.
     * gRPC error codes:
     *  * Invalid Argument (3): see the status description for details;
     *  * Internal (13): see the status description and logs for details;
     * </pre>
     *
     * <code>rpc Ack(.AckRq) returns (.AckRs);</code>
     */
    public abstract void ack(
            com.google.protobuf.RpcController controller,
            AckRq request,
            com.google.protobuf.RpcCallback<AckRs> done);

    /**
     * <pre>
     * Fetches partition offsets for the specified topic and group
     * gRPC error codes:
     *  * Invalid Argument (3): If unable to find the cluster named in the request
     *  * Internal (13): If Kafka returns an error on offset request
     *  * NotFound (5): If the group and or topic does not exist
     * </pre>
     *
     * <code>rpc GetOffsets(.GetOffsetsRq) returns (.GetOffsetsRs);</code>
     */
    public abstract void getOffsets(
            com.google.protobuf.RpcController controller,
            GetOffsetsRq request,
            com.google.protobuf.RpcCallback<GetOffsetsRs> done);

    /**
     * <pre>
     * Sets partition offsets for the specified topic and group.
     * NOTE: Although the request accepts the PartitionOffset object i
     * only 'Partition', 'Offset' and 'Metadata' are set by this method
     * gRPC error codes:
     *  * Invalid Argument (3): If unable to find the cluster named in the request
     *  * Internal (13): If Kafka returns an error on offset request
     *  * NotFound (5): If the group and or topic does not exist
     * </pre>
     *
     * <code>rpc SetOffsets(.SetOffsetsRq) returns (.SetOffsetsRs);</code>
     */
    public abstract void setOffsets(
            com.google.protobuf.RpcController controller,
            SetOffsetsRq request,
            com.google.protobuf.RpcCallback<SetOffsetsRs> done);

    /**
     * <pre>
     * Lists all topics and metadata with optional metadata for the partitions of the topic
     * gRPC error codes:
     *  * Invalid Argument (3): If unable to find the cluster named in the request
     *  * Internal (13): If Kafka returns an error on request
     * </pre>
     *
     * <code>rpc ListTopics(.ListTopicRq) returns (.ListTopicRs);</code>
     */
    public abstract void listTopics(
            com.google.protobuf.RpcController controller,
            ListTopicRq request,
            com.google.protobuf.RpcCallback<ListTopicRs> done);

    /**
     * <pre>
     * Lists all consumers of a topic
     * gRPC error codes:
     *  * Invalid Argument (3): If unable to find the cluster named in the request
     *  * Internal (13): If Kafka returns an error on request
     * </pre>
     *
     * <code>rpc ListConsumers(.ListConsumersRq) returns (.ListConsumersRs);</code>
     */
    public abstract void listConsumers(
            com.google.protobuf.RpcController controller,
            ListConsumersRq request,
            com.google.protobuf.RpcCallback<ListConsumersRs> done);

    /**
     * <pre>
     * Fetches topic metadata and optional metadata for the partitions of the topic
     * gRPC error codes:
     *  * Invalid Argument (3): If unable to find the cluster named in the request
     *  * Internal (13): If Kafka returns an error on request
     *  * NotFound (5): If the topic does not exist
     * </pre>
     *
     * <code>rpc GetTopicMetadata(.GetTopicMetadataRq) returns (.GetTopicMetadataRs);</code>
     */
    public abstract void getTopicMetadata(
            com.google.protobuf.RpcController controller,
            GetTopicMetadataRq request,
            com.google.protobuf.RpcCallback<GetTopicMetadataRs> done);

  }

  public static com.google.protobuf.Service newReflectiveService(
      final Interface impl) {
    return new KafkaPixyService() {
      @Override
      public  void produce(
          com.google.protobuf.RpcController controller,
          ProdRq request,
          com.google.protobuf.RpcCallback<ProdRs> done) {
        impl.produce(controller, request, done);
      }

      @Override
      public  void consumeNAck(
          com.google.protobuf.RpcController controller,
          ConsNAckRq request,
          com.google.protobuf.RpcCallback<ConsRs> done) {
        impl.consumeNAck(controller, request, done);
      }

      @Override
      public  void ack(
          com.google.protobuf.RpcController controller,
          AckRq request,
          com.google.protobuf.RpcCallback<AckRs> done) {
        impl.ack(controller, request, done);
      }

      @Override
      public  void getOffsets(
          com.google.protobuf.RpcController controller,
          GetOffsetsRq request,
          com.google.protobuf.RpcCallback<GetOffsetsRs> done) {
        impl.getOffsets(controller, request, done);
      }

      @Override
      public  void setOffsets(
          com.google.protobuf.RpcController controller,
          SetOffsetsRq request,
          com.google.protobuf.RpcCallback<SetOffsetsRs> done) {
        impl.setOffsets(controller, request, done);
      }

      @Override
      public  void listTopics(
          com.google.protobuf.RpcController controller,
          ListTopicRq request,
          com.google.protobuf.RpcCallback<ListTopicRs> done) {
        impl.listTopics(controller, request, done);
      }

      @Override
      public  void listConsumers(
          com.google.protobuf.RpcController controller,
          ListConsumersRq request,
          com.google.protobuf.RpcCallback<ListConsumersRs> done) {
        impl.listConsumers(controller, request, done);
      }

      @Override
      public  void getTopicMetadata(
          com.google.protobuf.RpcController controller,
          GetTopicMetadataRq request,
          com.google.protobuf.RpcCallback<GetTopicMetadataRs> done) {
        impl.getTopicMetadata(controller, request, done);
      }

    };
  }

  public static com.google.protobuf.BlockingService
      newReflectiveBlockingService(final BlockingInterface impl) {
    return new com.google.protobuf.BlockingService() {
      public final com.google.protobuf.Descriptors.ServiceDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }

      public final com.google.protobuf.Message callBlockingMethod(
          com.google.protobuf.Descriptors.MethodDescriptor method,
          com.google.protobuf.RpcController controller,
          com.google.protobuf.Message request)
          throws com.google.protobuf.ServiceException {
        if (method.getService() != getDescriptor()) {
          throw new IllegalArgumentException(
            "Service.callBlockingMethod() given method descriptor for " +
            "wrong service type.");
        }
        switch(method.getIndex()) {
          case 0:
            return impl.produce(controller, (ProdRq)request);
          case 1:
            return impl.consumeNAck(controller, (ConsNAckRq)request);
          case 2:
            return impl.ack(controller, (AckRq)request);
          case 3:
            return impl.getOffsets(controller, (GetOffsetsRq)request);
          case 4:
            return impl.setOffsets(controller, (SetOffsetsRq)request);
          case 5:
            return impl.listTopics(controller, (ListTopicRq)request);
          case 6:
            return impl.listConsumers(controller, (ListConsumersRq)request);
          case 7:
            return impl.getTopicMetadata(controller, (GetTopicMetadataRq)request);
          default:
            throw new AssertionError("Can't get here.");
        }
      }

      public final com.google.protobuf.Message
          getRequestPrototype(
          com.google.protobuf.Descriptors.MethodDescriptor method) {
        if (method.getService() != getDescriptor()) {
          throw new IllegalArgumentException(
            "Service.getRequestPrototype() given method " +
            "descriptor for wrong service type.");
        }
        switch(method.getIndex()) {
          case 0:
            return ProdRq.getDefaultInstance();
          case 1:
            return ConsNAckRq.getDefaultInstance();
          case 2:
            return AckRq.getDefaultInstance();
          case 3:
            return GetOffsetsRq.getDefaultInstance();
          case 4:
            return SetOffsetsRq.getDefaultInstance();
          case 5:
            return ListTopicRq.getDefaultInstance();
          case 6:
            return ListConsumersRq.getDefaultInstance();
          case 7:
            return GetTopicMetadataRq.getDefaultInstance();
          default:
            throw new AssertionError("Can't get here.");
        }
      }

      public final com.google.protobuf.Message
          getResponsePrototype(
          com.google.protobuf.Descriptors.MethodDescriptor method) {
        if (method.getService() != getDescriptor()) {
          throw new IllegalArgumentException(
            "Service.getResponsePrototype() given method " +
            "descriptor for wrong service type.");
        }
        switch(method.getIndex()) {
          case 0:
            return ProdRs.getDefaultInstance();
          case 1:
            return ConsRs.getDefaultInstance();
          case 2:
            return AckRs.getDefaultInstance();
          case 3:
            return GetOffsetsRs.getDefaultInstance();
          case 4:
            return SetOffsetsRs.getDefaultInstance();
          case 5:
            return ListTopicRs.getDefaultInstance();
          case 6:
            return ListConsumersRs.getDefaultInstance();
          case 7:
            return GetTopicMetadataRs.getDefaultInstance();
          default:
            throw new AssertionError("Can't get here.");
        }
      }

    };
  }

  /**
   * <pre>
   * Produce writes a message to a Kafka topic.
   * If ProdReq.async_mode is false (default value) then the request will
   * block until the message is written to all ISR. In this case the respose
   * will contain the partition and offset of the message. This has to be
   * used to achive at-least-once deliverability guarantee.
   * If ProdReq.async_mode is true, then Kafka-Pixy returns immediately after
   * it gets the request and performs write on the backgroud. This mode
   * ensures highest throughput but messages can be lost, e.g. if the host
   * crashes before Kafka-Pixy has a chance to complete write.
   * Hash of ProdReq.key_value is used to determine a partition that the
   * message should be written to. If you want a message to go to an random
   * partition then set ProdReq.key_undefined to true. Note that if both
   * ProdReq.key_undefined and ProdReq.key_value are left default, which is
   * empty string and false respectively, then messages will be consitently
   * written to a partiticular partition selected by the hash of an empty
   * string.
   * gRPC error codes:
   *  * Invalid Argument (3): see the status description for details;
   *  * Internal (13): see the status description and logs for details;
   *  * Unavailable (14): the service is shutting down.
   * </pre>
   *
   * <code>rpc Produce(.ProdRq) returns (.ProdRs);</code>
   */
  public abstract void produce(
      com.google.protobuf.RpcController controller,
      ProdRq request,
      com.google.protobuf.RpcCallback<ProdRs> done);

  /**
   * <pre>
   * Consume reads a message from a topic and optionally acknowledges a
   * message previously consumed from the same topic.
   * Requests are performed in long polling fation, that is if all available
   * messages have been consumed then the request will block for
   * config.yaml:proxies.&lt;cluster&gt;.consumer.long_polling_timeout waiting for
   * new messages. If no new messages is produced while waiting the request
   * will return gRPC error with 408 status code.
   * To consume the first message set ConsNAckReq.no_ack to true, since there
   * is no message to acknowledge at this point. In the second and all
   * subsequent calls of the method set ConsNAckReq.ack_partition and
   * ConsNAckReq.ack_offset to the respective values of ConsRes returned by
   * the previous method call. To acknowledge the last consumed message before
   * teminating the application call Ack method.
   * If a message is not acknowledged within
   * config.yaml:proxies.&lt;cluster&gt;.consumer.ack_timeout the it will be returned
   * by Kafka-Pixy in ConsRes again possibly to another application.
   * If at-least-once delivery guarantee and retries are not desirable, then
   * you can set ConsNAckReq.auto_ack to true and Kafka-Pixy will acknowledge
   * messages automatically before returning them in ConsRes.
   * gRPC error codes:
   *  * Not Found (5): It just means that all message has been consumed and
   *    the long polling timeout has elaspsed. Just keep calling this method
   *    in a loop;
   *  * Resource Exhausted (8): too many consume requests. Either reduce the
   *    number of consuming threads or increase
   *    config.yaml:proxies.&lt;cluster&gt;.consumer.channel_buffer_size;
   *  * Invalid Argument (3): see the status description for details;
   *  * Internal (13): see the status description and logs for details;
   *  * Unavailable (14): the service is shutting down.
   * </pre>
   *
   * <code>rpc ConsumeNAck(.ConsNAckRq) returns (.ConsRs);</code>
   */
  public abstract void consumeNAck(
      com.google.protobuf.RpcController controller,
      ConsNAckRq request,
      com.google.protobuf.RpcCallback<ConsRs> done);

  /**
   * <pre>
   * Ack acknowledges a message earlier consumed from a topic.
   * This method is provided solely to acknowledge the last consumed message
   * before the application terminates. In all other cases ConsumeNAck should
   * be used.
   * gRPC error codes:
   *  * Invalid Argument (3): see the status description for details;
   *  * Internal (13): see the status description and logs for details;
   * </pre>
   *
   * <code>rpc Ack(.AckRq) returns (.AckRs);</code>
   */
  public abstract void ack(
      com.google.protobuf.RpcController controller,
      AckRq request,
      com.google.protobuf.RpcCallback<AckRs> done);

  /**
   * <pre>
   * Fetches partition offsets for the specified topic and group
   * gRPC error codes:
   *  * Invalid Argument (3): If unable to find the cluster named in the request
   *  * Internal (13): If Kafka returns an error on offset request
   *  * NotFound (5): If the group and or topic does not exist
   * </pre>
   *
   * <code>rpc GetOffsets(.GetOffsetsRq) returns (.GetOffsetsRs);</code>
   */
  public abstract void getOffsets(
      com.google.protobuf.RpcController controller,
      GetOffsetsRq request,
      com.google.protobuf.RpcCallback<GetOffsetsRs> done);

  /**
   * <pre>
   * Sets partition offsets for the specified topic and group.
   * NOTE: Although the request accepts the PartitionOffset object i
   * only 'Partition', 'Offset' and 'Metadata' are set by this method
   * gRPC error codes:
   *  * Invalid Argument (3): If unable to find the cluster named in the request
   *  * Internal (13): If Kafka returns an error on offset request
   *  * NotFound (5): If the group and or topic does not exist
   * </pre>
   *
   * <code>rpc SetOffsets(.SetOffsetsRq) returns (.SetOffsetsRs);</code>
   */
  public abstract void setOffsets(
      com.google.protobuf.RpcController controller,
      SetOffsetsRq request,
      com.google.protobuf.RpcCallback<SetOffsetsRs> done);

  /**
   * <pre>
   * Lists all topics and metadata with optional metadata for the partitions of the topic
   * gRPC error codes:
   *  * Invalid Argument (3): If unable to find the cluster named in the request
   *  * Internal (13): If Kafka returns an error on request
   * </pre>
   *
   * <code>rpc ListTopics(.ListTopicRq) returns (.ListTopicRs);</code>
   */
  public abstract void listTopics(
      com.google.protobuf.RpcController controller,
      ListTopicRq request,
      com.google.protobuf.RpcCallback<ListTopicRs> done);

  /**
   * <pre>
   * Lists all consumers of a topic
   * gRPC error codes:
   *  * Invalid Argument (3): If unable to find the cluster named in the request
   *  * Internal (13): If Kafka returns an error on request
   * </pre>
   *
   * <code>rpc ListConsumers(.ListConsumersRq) returns (.ListConsumersRs);</code>
   */
  public abstract void listConsumers(
      com.google.protobuf.RpcController controller,
      ListConsumersRq request,
      com.google.protobuf.RpcCallback<ListConsumersRs> done);

  /**
   * <pre>
   * Fetches topic metadata and optional metadata for the partitions of the topic
   * gRPC error codes:
   *  * Invalid Argument (3): If unable to find the cluster named in the request
   *  * Internal (13): If Kafka returns an error on request
   *  * NotFound (5): If the topic does not exist
   * </pre>
   *
   * <code>rpc GetTopicMetadata(.GetTopicMetadataRq) returns (.GetTopicMetadataRs);</code>
   */
  public abstract void getTopicMetadata(
      com.google.protobuf.RpcController controller,
      GetTopicMetadataRq request,
      com.google.protobuf.RpcCallback<GetTopicMetadataRs> done);

  public static final
      com.google.protobuf.Descriptors.ServiceDescriptor
      getDescriptor() {
    return Kafkapixy.getDescriptor().getServices().get(0);
  }
  public final com.google.protobuf.Descriptors.ServiceDescriptor
      getDescriptorForType() {
    return getDescriptor();
  }

  public final void callMethod(
      com.google.protobuf.Descriptors.MethodDescriptor method,
      com.google.protobuf.RpcController controller,
      com.google.protobuf.Message request,
      com.google.protobuf.RpcCallback<
        com.google.protobuf.Message> done) {
    if (method.getService() != getDescriptor()) {
      throw new IllegalArgumentException(
        "Service.callMethod() given method descriptor for wrong " +
        "service type.");
    }
    switch(method.getIndex()) {
      case 0:
        this.produce(controller, (ProdRq)request,
          com.google.protobuf.RpcUtil.<ProdRs>specializeCallback(
            done));
        return;
      case 1:
        this.consumeNAck(controller, (ConsNAckRq)request,
          com.google.protobuf.RpcUtil.<ConsRs>specializeCallback(
            done));
        return;
      case 2:
        this.ack(controller, (AckRq)request,
          com.google.protobuf.RpcUtil.<AckRs>specializeCallback(
            done));
        return;
      case 3:
        this.getOffsets(controller, (GetOffsetsRq)request,
          com.google.protobuf.RpcUtil.<GetOffsetsRs>specializeCallback(
            done));
        return;
      case 4:
        this.setOffsets(controller, (SetOffsetsRq)request,
          com.google.protobuf.RpcUtil.<SetOffsetsRs>specializeCallback(
            done));
        return;
      case 5:
        this.listTopics(controller, (ListTopicRq)request,
          com.google.protobuf.RpcUtil.<ListTopicRs>specializeCallback(
            done));
        return;
      case 6:
        this.listConsumers(controller, (ListConsumersRq)request,
          com.google.protobuf.RpcUtil.<ListConsumersRs>specializeCallback(
            done));
        return;
      case 7:
        this.getTopicMetadata(controller, (GetTopicMetadataRq)request,
          com.google.protobuf.RpcUtil.<GetTopicMetadataRs>specializeCallback(
            done));
        return;
      default:
        throw new AssertionError("Can't get here.");
    }
  }

  public final com.google.protobuf.Message
      getRequestPrototype(
      com.google.protobuf.Descriptors.MethodDescriptor method) {
    if (method.getService() != getDescriptor()) {
      throw new IllegalArgumentException(
        "Service.getRequestPrototype() given method " +
        "descriptor for wrong service type.");
    }
    switch(method.getIndex()) {
      case 0:
        return ProdRq.getDefaultInstance();
      case 1:
        return ConsNAckRq.getDefaultInstance();
      case 2:
        return AckRq.getDefaultInstance();
      case 3:
        return GetOffsetsRq.getDefaultInstance();
      case 4:
        return SetOffsetsRq.getDefaultInstance();
      case 5:
        return ListTopicRq.getDefaultInstance();
      case 6:
        return ListConsumersRq.getDefaultInstance();
      case 7:
        return GetTopicMetadataRq.getDefaultInstance();
      default:
        throw new AssertionError("Can't get here.");
    }
  }

  public final com.google.protobuf.Message
      getResponsePrototype(
      com.google.protobuf.Descriptors.MethodDescriptor method) {
    if (method.getService() != getDescriptor()) {
      throw new IllegalArgumentException(
        "Service.getResponsePrototype() given method " +
        "descriptor for wrong service type.");
    }
    switch(method.getIndex()) {
      case 0:
        return ProdRs.getDefaultInstance();
      case 1:
        return ConsRs.getDefaultInstance();
      case 2:
        return AckRs.getDefaultInstance();
      case 3:
        return GetOffsetsRs.getDefaultInstance();
      case 4:
        return SetOffsetsRs.getDefaultInstance();
      case 5:
        return ListTopicRs.getDefaultInstance();
      case 6:
        return ListConsumersRs.getDefaultInstance();
      case 7:
        return GetTopicMetadataRs.getDefaultInstance();
      default:
        throw new AssertionError("Can't get here.");
    }
  }

  public static Stub newStub(
      com.google.protobuf.RpcChannel channel) {
    return new Stub(channel);
  }

  public static final class Stub extends KafkaPixyService implements Interface {
    private Stub(com.google.protobuf.RpcChannel channel) {
      this.channel = channel;
    }

    private final com.google.protobuf.RpcChannel channel;

    public com.google.protobuf.RpcChannel getChannel() {
      return channel;
    }

    public  void produce(
        com.google.protobuf.RpcController controller,
        ProdRq request,
        com.google.protobuf.RpcCallback<ProdRs> done) {
      channel.callMethod(
        getDescriptor().getMethods().get(0),
        controller,
        request,
        ProdRs.getDefaultInstance(),
        com.google.protobuf.RpcUtil.generalizeCallback(
          done,
          ProdRs.class,
          ProdRs.getDefaultInstance()));
    }

    public  void consumeNAck(
        com.google.protobuf.RpcController controller,
        ConsNAckRq request,
        com.google.protobuf.RpcCallback<ConsRs> done) {
      channel.callMethod(
        getDescriptor().getMethods().get(1),
        controller,
        request,
        ConsRs.getDefaultInstance(),
        com.google.protobuf.RpcUtil.generalizeCallback(
          done,
          ConsRs.class,
          ConsRs.getDefaultInstance()));
    }

    public  void ack(
        com.google.protobuf.RpcController controller,
        AckRq request,
        com.google.protobuf.RpcCallback<AckRs> done) {
      channel.callMethod(
        getDescriptor().getMethods().get(2),
        controller,
        request,
        AckRs.getDefaultInstance(),
        com.google.protobuf.RpcUtil.generalizeCallback(
          done,
          AckRs.class,
          AckRs.getDefaultInstance()));
    }

    public  void getOffsets(
        com.google.protobuf.RpcController controller,
        GetOffsetsRq request,
        com.google.protobuf.RpcCallback<GetOffsetsRs> done) {
      channel.callMethod(
        getDescriptor().getMethods().get(3),
        controller,
        request,
        GetOffsetsRs.getDefaultInstance(),
        com.google.protobuf.RpcUtil.generalizeCallback(
          done,
          GetOffsetsRs.class,
          GetOffsetsRs.getDefaultInstance()));
    }

    public  void setOffsets(
        com.google.protobuf.RpcController controller,
        SetOffsetsRq request,
        com.google.protobuf.RpcCallback<SetOffsetsRs> done) {
      channel.callMethod(
        getDescriptor().getMethods().get(4),
        controller,
        request,
        SetOffsetsRs.getDefaultInstance(),
        com.google.protobuf.RpcUtil.generalizeCallback(
          done,
          SetOffsetsRs.class,
          SetOffsetsRs.getDefaultInstance()));
    }

    public  void listTopics(
        com.google.protobuf.RpcController controller,
        ListTopicRq request,
        com.google.protobuf.RpcCallback<ListTopicRs> done) {
      channel.callMethod(
        getDescriptor().getMethods().get(5),
        controller,
        request,
        ListTopicRs.getDefaultInstance(),
        com.google.protobuf.RpcUtil.generalizeCallback(
          done,
          ListTopicRs.class,
          ListTopicRs.getDefaultInstance()));
    }

    public  void listConsumers(
        com.google.protobuf.RpcController controller,
        ListConsumersRq request,
        com.google.protobuf.RpcCallback<ListConsumersRs> done) {
      channel.callMethod(
        getDescriptor().getMethods().get(6),
        controller,
        request,
        ListConsumersRs.getDefaultInstance(),
        com.google.protobuf.RpcUtil.generalizeCallback(
          done,
          ListConsumersRs.class,
          ListConsumersRs.getDefaultInstance()));
    }

    public  void getTopicMetadata(
        com.google.protobuf.RpcController controller,
        GetTopicMetadataRq request,
        com.google.protobuf.RpcCallback<GetTopicMetadataRs> done) {
      channel.callMethod(
        getDescriptor().getMethods().get(7),
        controller,
        request,
        GetTopicMetadataRs.getDefaultInstance(),
        com.google.protobuf.RpcUtil.generalizeCallback(
          done,
          GetTopicMetadataRs.class,
          GetTopicMetadataRs.getDefaultInstance()));
    }
  }

  public static BlockingInterface newBlockingStub(
      com.google.protobuf.BlockingRpcChannel channel) {
    return new BlockingStub(channel);
  }

  public interface BlockingInterface {
    public ProdRs produce(
            com.google.protobuf.RpcController controller,
            ProdRq request)
        throws com.google.protobuf.ServiceException;

    public ConsRs consumeNAck(
            com.google.protobuf.RpcController controller,
            ConsNAckRq request)
        throws com.google.protobuf.ServiceException;

    public AckRs ack(
            com.google.protobuf.RpcController controller,
            AckRq request)
        throws com.google.protobuf.ServiceException;

    public GetOffsetsRs getOffsets(
            com.google.protobuf.RpcController controller,
            GetOffsetsRq request)
        throws com.google.protobuf.ServiceException;

    public SetOffsetsRs setOffsets(
            com.google.protobuf.RpcController controller,
            SetOffsetsRq request)
        throws com.google.protobuf.ServiceException;

    public ListTopicRs listTopics(
            com.google.protobuf.RpcController controller,
            ListTopicRq request)
        throws com.google.protobuf.ServiceException;

    public ListConsumersRs listConsumers(
            com.google.protobuf.RpcController controller,
            ListConsumersRq request)
        throws com.google.protobuf.ServiceException;

    public GetTopicMetadataRs getTopicMetadata(
            com.google.protobuf.RpcController controller,
            GetTopicMetadataRq request)
        throws com.google.protobuf.ServiceException;
  }

  private static final class BlockingStub implements BlockingInterface {
    private BlockingStub(com.google.protobuf.BlockingRpcChannel channel) {
      this.channel = channel;
    }

    private final com.google.protobuf.BlockingRpcChannel channel;

    public ProdRs produce(
        com.google.protobuf.RpcController controller,
        ProdRq request)
        throws com.google.protobuf.ServiceException {
      return (ProdRs) channel.callBlockingMethod(
        getDescriptor().getMethods().get(0),
        controller,
        request,
        ProdRs.getDefaultInstance());
    }


    public ConsRs consumeNAck(
        com.google.protobuf.RpcController controller,
        ConsNAckRq request)
        throws com.google.protobuf.ServiceException {
      return (ConsRs) channel.callBlockingMethod(
        getDescriptor().getMethods().get(1),
        controller,
        request,
        ConsRs.getDefaultInstance());
    }


    public AckRs ack(
        com.google.protobuf.RpcController controller,
        AckRq request)
        throws com.google.protobuf.ServiceException {
      return (AckRs) channel.callBlockingMethod(
        getDescriptor().getMethods().get(2),
        controller,
        request,
        AckRs.getDefaultInstance());
    }


    public GetOffsetsRs getOffsets(
        com.google.protobuf.RpcController controller,
        GetOffsetsRq request)
        throws com.google.protobuf.ServiceException {
      return (GetOffsetsRs) channel.callBlockingMethod(
        getDescriptor().getMethods().get(3),
        controller,
        request,
        GetOffsetsRs.getDefaultInstance());
    }


    public SetOffsetsRs setOffsets(
        com.google.protobuf.RpcController controller,
        SetOffsetsRq request)
        throws com.google.protobuf.ServiceException {
      return (SetOffsetsRs) channel.callBlockingMethod(
        getDescriptor().getMethods().get(4),
        controller,
        request,
        SetOffsetsRs.getDefaultInstance());
    }


    public ListTopicRs listTopics(
        com.google.protobuf.RpcController controller,
        ListTopicRq request)
        throws com.google.protobuf.ServiceException {
      return (ListTopicRs) channel.callBlockingMethod(
        getDescriptor().getMethods().get(5),
        controller,
        request,
        ListTopicRs.getDefaultInstance());
    }


    public ListConsumersRs listConsumers(
        com.google.protobuf.RpcController controller,
        ListConsumersRq request)
        throws com.google.protobuf.ServiceException {
      return (ListConsumersRs) channel.callBlockingMethod(
        getDescriptor().getMethods().get(6),
        controller,
        request,
        ListConsumersRs.getDefaultInstance());
    }


    public GetTopicMetadataRs getTopicMetadata(
        com.google.protobuf.RpcController controller,
        GetTopicMetadataRq request)
        throws com.google.protobuf.ServiceException {
      return (GetTopicMetadataRs) channel.callBlockingMethod(
        getDescriptor().getMethods().get(7),
        controller,
        request,
        GetTopicMetadataRs.getDefaultInstance());
    }

  }

  // @@protoc_insertion_point(class_scope:KafkaPixyService)
}

